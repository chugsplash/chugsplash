import {
  ensureSphinxInitialized,
  SphinxJsonRpcProvider,
  isLiveNetwork,
} from '@sphinx-labs/core'
import { ethers } from 'ethers'

const args = process.argv.slice(2)
const command = args[0]

;(async () => {
  switch (command) {
    case 'deployOnAnvil': {
      const rpcUrl = args[1]
      const executor = args[2]
      const executorArray = executor !== ethers.ZeroAddress ? [executor] : []
      const provider = new SphinxJsonRpcProvider(rpcUrl)

      // Next, we create and fund a couple auto-generated addresses. We don't use the default
      // private keys generated by Anvil/Hardhat because the user may be using one of these private
      // keys as their deployer. If we use the same private key, then the user's deployer nonce will
      // be incremented in this logic, which will cause a nonce mismatch error in the user's
      // deployment.
      const firstSphinxPrivateKey = ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(
          ['string', 'uint256'],
          ['sphinx.deployer', 0]
        )
      )
      const secondSphinxPrivateKey = ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(
          ['string', 'uint256'],
          ['sphinx.deployer', 1]
        )
      )
      // Set the balance of the auto-generated addresses. The 'hardhat_setBalance' RPC method works on
      // Anvil and Hardhat nodes, whereas 'anvil_setBalance' only works on Anvil nodes.
      await provider.send('hardhat_setBalance', [
        new ethers.Wallet(firstSphinxPrivateKey).address,
        ethers.toBeHex(ethers.parseEther('100')),
      ])
      // We use the second address to deploy the Sphinx contracts here because we use the first
      // address to deploy the user's contracts when broadcasting on Anvil. If we use the same
      // address for both purposes, then its nonce will be incremented in this logic, causing a
      // nonce mismatch error in the user's deployment, leading it to fail.
      const wallet = new ethers.Wallet(secondSphinxPrivateKey, provider)
      await provider.send('hardhat_setBalance', [
        wallet.address,
        ethers.toBeHex(ethers.parseEther('100')),
      ])

      await ensureSphinxInitialized(provider, wallet, executorArray, [], [])

      break
    }
    case 'isLiveNetwork': {
      const rpcUrl = args[1]
      const provider = new SphinxJsonRpcProvider(rpcUrl)

      const abiEncodedResult = ethers.AbiCoder.defaultAbiCoder().encode(
        ['bool'],
        [await isLiveNetwork(provider)]
      )

      process.stdout.write(abiEncodedResult)
      break
    }
  }
})()
